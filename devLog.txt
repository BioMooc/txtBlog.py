################################
project name: txtBlog.py

#local url:http://blog2.163.com/
#dir:G:\xampp\htdocs\163
################################

# 使用flask框架，尽量简化。https://flask.palletsprojects.com/en/1.1.x/
# 顶部关键词，左侧文件名。使用json做配置文件。
# 预计支持html/txt格式的文档。尽量留下扩展。

#quick start: https://flask.palletsprojects.com/en/1.1.x/quickstart/#quickstart
每次改动需要重启才能生效

################################
1.如何从路由器传入参数
hello.py 最简单服务器

(1)路由器
hello2.py 路由器Routing

@app.route('/hello')
def hello():
    return 'Hello, World'

(2)传入参数
from flask import Flask, escape, url_for
#从url传入get参数
@app.route('/index.py')
def hello2():
    kw = request.args.get("k", "Python")
    id = request.args.get("id", "0_0")
    return f'keyword:{escape(kw)}<br> \
	          id: {escape(id)}'
# http://blog2.163.com:8000/index.py?k=R&id=3_4
# keyword:R
# id: 3_4

(3)使用 url_for() 生成URL
from flask import Flask, escape, url_for
url_for('index', k='Java',id="0_0")
#第一个参数是函数名，不是路由。必须定义过，否则报错。
#输出的路径是按照路由构建的，与函数名无关。

实例
from flask import Flask, escape,request, url_for
app = Flask(__name__)

#生成url
@app.route('/')
def index():
    urls=url_for('hello2', k='Java',id="0_0") #第一个参数是函数名，不是路由
    return '<a target=_blank href='+urls+'>index</a> '+urls

#1.从url传入get参数:k和id
@app.route('/index.py')
def hello2():
    kw = request.args.get("k", "Python")
    id = request.args.get("id", "0_0")
    return f'keyword:{escape(kw)}<br> \
	          id: {escape(id)}'
# http://blog2.163.com:8000/index.py?k=Java&id=0_0
# keyword:k:Java
# id: 0_0

#2.直接从url分离参数：k和id
@app.route('/s/<keyword>/<id>')
def profile(keyword,id):
    return 'k:{} <br>id:{}'.format(escape(keyword), escape(id))
# http://blog2.163.com:8000/s/Java/0_0
# k:Java 
# id:0_0


if __name__ == '__main__':
    app.run(host="blog2.163.com",port=8000)
#

################################
2. 如何从关键词读取json文件，找到txt文件,并显示内容
#数据文件
[
	{
		'title':"前沿与资料",
		'data':
		[
			["项目描述", "R001", "html"],
			["参考资料", "R-plot", "txt" ]
		]
	},
	{
		'title':"R语法",
		'data':
		[
			["入门", "R002", "txt"],
			["ggplot2", "R-ggplot2", "txt" ],
			["R高级", "R-adv", "txt" ]
		]
	}
]

#读取方式
import json,re
import sys


#k="R"
#id="0_0"

k=sys.argv[1]
id=sys.argv[2]

#文本文件阅读器，放到lib中
def txtReader(fpath):
	print(fpath)
	fr=open(fpath, 'r', encoding="utf8")
	tmp=""
	for lineR in fr.readlines():
		line=lineR.strip()
		tmp+=line+"<br>";
		print(tmp)
	#关闭文件
	fr.close()
	return tmp;
#
htmlReader=txtReader #todo

def getData(k,id):
	#1.解析id为2个数字
	arr=re.split("_", id)
	n0=int(arr[0])
	n1=int(arr[1])

	#2.解析json文件获取左侧目录，和文件名字
	load_f=open("data/R.json",'r',encoding="utf8")
	#读取json
	menus = json.load(load_f)

	#凑出来文件路径
	menuCur =  menus[n0]["data"][n1]
	filepath="data/"+k+"/"+menuCur[1]+"."+menuCur[2] #路径
	suffix=menuCur[2] #后缀

	#拼凑出超链接
	url_left=""
	for i in range(len(menus)):
		#print("="*10,menus[i]["title"]);
		url_left+="<h5 class=title>"+menus[i]["title"]+"</h5>\n<ul class=submenu>\n";

		arr2=menus[i]["data"];
		for j in range(len(arr2)):
			#print("title=",arr2[j][0], str(i)+"_"+str(j) )
			cur=""
			if i==n0 and j==n1:
				cur=" class=cur"
			#
			url_left+="<li"+cur+"><a href=" + str(i)+"_"+str(j) +">"+arr2[j][0]+"</a></li>\n"
		url_left+="</ul>\n"
	#关闭文件
	load_f.close();

	#根据文件类型，读取文件
	content="";
	if suffix=="html":
		content=htmlReader(filepath)
	elif suffix=="txt":
		content=txtReader(filepath)
	return (url_left, content,filepath)

#rs=getData("R","0_1")
rs=getData(k,id)
print("url_left=",rs[0])
print("="*50)
print('content=',rs[1])
print("="*50)
print('filepath=',rs[2])


运行：
python getDataFrom_k_id.py R 0_1

################################
3. 把step2显示到网页中

添加topMenu
添加bottom link region

################################
4. 装饰上html


v0.0.1 py框架基本可用，有顶部menu和左侧menu，有右侧内容了。
v0.0.2 套用了css格式，支持txt，支持无图html文件
v0.0.3 支持html插入非static/下的图片了
v0.0.4 底部链接搞定。
v0.0.5 添加使用说明 ReadMe.txt
v0.0.6 微调说明文档。
v0.0.7-1 微调txt阅读器函数
v0.0.7-2 txt.js在txt解析器内部引用; 默认是txt解析器; txt解析器转码2个尖括号; 处理文档不存在;
	{% if suffix=="txt" %}{% endif %}
开始研究添加md解析器
v0.0.7-3 支持md了
	后缀名可以是makdown或md都行。
	添加三套皮肤: MarkDown.css, MarkDown2.css(线条形状), MarkDown3.css(现在github的样式表，.markdown-body 替换为 .markdown), 
	md1 是github原来使用的，现在使用的md3更紧凑，调整了颜色。
v0.0.7-4 fix bug: txt.js 目录单击时锚点错了一行，已经微调.

#

	

todo:
1.md 不支持代码高亮
2.md不支持自动生成目录。


